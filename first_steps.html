<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="generator" content="Doxygen 1.8.17"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>DDC: Commented example: the heat equation</title>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<script type="text/javascript" src="navtreedata.js"></script>
	<script type="text/javascript" src="navtree.js"></script>
	<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div>
<header id="titlearea">
	<div id="projectlogo"><a href="index.html"><img alt="Logo" src="logo.png"/></a></div>
	<h1 id="projectname">DDC&nbsp;<span id="projectnumber">0.0.0</span></h1>
	<h2 id="projectbrief">a <span class="acronym">d</span>iscrete <span class="acronym">d</span>omain <span class="acronym">c</span>omputation library</h2>
</header>
<nav id="tabs"><ul>
	<li><a href="index.html">About</a>
	<li><a href="first_steps.html">Commented example</a>
	<li><a href="annotated.html">API reference</a>
	<li id="gitlab-ribbon"><a rel="noopener" href="https://github.com/Maison-de-la-Simulation/ddc" target="_blank">Contribute on Github</a></li>
</ul></nav>
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('first_steps.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Commented example: the heat equation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In <a class="el" href="heat_equation.html">examples/heat_equation.cpp</a> is a DDC example implementing a forward finite-difference solver for the heat equation over a rectangle 2D domain with periodic boundary conditions.</p>
<p>As usual, the file starts with a few includes that will be used in the code.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;ddc/Chunk&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ddc/DiscreteCoordinate&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ddc/DiscreteDomain&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ddc/DiscreteVector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ddc/UniformDiscretization&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ddc/for_each&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;ddc/transform_reduce&gt;</span></div>
</div><!-- fragment --><p> As you can see, DDC includes all follow the same convention: <code>&lt;ddc/SYMBOL&gt;</code> where <code>SYMBOL</code> is a the name of a DDC symbol. So for example, in order to use a class named <code><a class="el" href="namespace_3globalScope_4.html#classChunk">Chunk</a></code>, you should include <code>&lt;ddc/Chunk&gt;</code> and to use a free function template named <code>for_each</code>, you should include <code>&lt;ddc/for_each&gt;</code>.</p>
<p>Then, we define the value of some parameters that would typically be read from some form of configuration file in a more realistic code.</p>
<div class="fragment"><div class="line"><span class="comment">// Start of the domain of interest in the X dimension</span></div>
<div class="line"><span class="keywordtype">double</span> <span class="keyword">const</span> x_start = -1.;</div>
<div class="line"><span class="comment">// End of the domain of interest in the X dimension</span></div>
<div class="line"><span class="keywordtype">double</span> <span class="keyword">const</span> x_end = 1.;</div>
<div class="line"><span class="comment">// Number of discretization points in the X dimension</span></div>
<div class="line"><span class="keywordtype">size_t</span> <span class="keyword">const</span> nb_x_points = 10;</div>
<div class="line"><span class="comment">// Thermal diffusion coefficient</span></div>
<div class="line"><span class="keywordtype">double</span> <span class="keyword">const</span> kx = .01;</div>
<div class="line"><span class="comment">// Start of the domain of interest in the Y dimension</span></div>
<div class="line"><span class="keywordtype">double</span> <span class="keyword">const</span> y_start = -1.;</div>
<div class="line"><span class="comment">// End of the domain of interest in the Y dimension</span></div>
<div class="line"><span class="keywordtype">double</span> <span class="keyword">const</span> y_end = 1.;</div>
<div class="line"><span class="comment">// Number of discretization points in the Y dimension</span></div>
<div class="line"><span class="keywordtype">size_t</span> <span class="keyword">const</span> nb_y_points = 100;</div>
<div class="line"><span class="comment">// Thermal diffusion coefficient</span></div>
<div class="line"><span class="keywordtype">double</span> <span class="keyword">const</span> ky = .002;</div>
<div class="line"><span class="comment">// Simulated time at which to start simulation</span></div>
<div class="line"><span class="keywordtype">double</span> <span class="keyword">const</span> start_time = 0.;</div>
<div class="line"><span class="comment">// Simulated time to reach as target of the simulation</span></div>
<div class="line"><span class="keywordtype">double</span> <span class="keyword">const</span> end_time = 10.;</div>
<div class="line"><span class="comment">// Number of time-steps between outputs</span></div>
<div class="line"><span class="keywordtype">size_t</span> <span class="keyword">const</span> t_output_period = 10;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md2"></a>
Definition of the discretization</h1>
<p>Given the previous parameters, we will now define a 2D point discretization.</p>
<div class="image">
<img src="domains.png" alt=""/>
<div class="caption">
domains_image</div></div>
   <h2><a class="anchor" id="autotoc_md3"></a>
Dimensions naming</h2>
<p>Before starting the <code>main</code> function, we start by defining types that we later use to name our dimensions.</p>
<p>First, we create <code>X</code>: a type that is declared but never defined to act as a tag identifying our first dimension.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>X;</div>
</div><!-- fragment --><p> Then, we create <code>DDimX</code>, a type that will also act as a tag, but we define it to be a uniform discretization of <code>X</code>. Thus <code>DDimX</code> is an identifier for a discrete dimension.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> DDimX = <a class="code" href="classUniformDiscretization.html">UniformDiscretization&lt;X&gt;</a>;</div>
</div><!-- fragment --><p> We do the same thing for the second dimension <code>Y</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// Our second continuous dimension</span></div>
<div class="line"><span class="keyword">struct </span>Y;</div>
<div class="line"><span class="comment">// Its uniform discretization</span></div>
<div class="line"><span class="keyword">using</span> DDimY = <a class="code" href="classUniformDiscretization.html">UniformDiscretization&lt;Y&gt;</a>;</div>
</div><!-- fragment --><p> And once again, now for the time dimension.</p>
<div class="fragment"><div class="line"><span class="comment">// Our simulated time dimension</span></div>
<div class="line"><span class="keyword">struct </span>T;</div>
<div class="line"><span class="comment">// Its uniform discretization</span></div>
<div class="line"><span class="keyword">using</span> DDimT = <a class="code" href="classUniformDiscretization.html">UniformDiscretization&lt;T&gt;</a>;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Domains</h2>
<h3><a class="anchor" id="autotoc_md5"></a>
Dimension X</h3>
<p>Once the types are defined, we can start the <code>main</code> function where we will define our various domains.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
</div><!-- fragment --><p> We start by defining <code>gwx</code>, the number of "ghost" points in the <code>X</code> dimension. This can be made <code>static constexpr</code> since here this is a compile-time constant. The type for this constant is <code>DiscreteVector&lt;DDimX&gt;</code> that represents a number of elements in the discretization of the <code>X</code> dimension.</p>
<div class="fragment"><div class="line">    <span class="comment">// Number of ghost points to use on each side in X</span></div>
<div class="line">    DiscreteVector&lt;DDimX&gt; <span class="keyword">static</span> constexpr gwx {1};</div>
</div><!-- fragment --><p> Once done, we initialize the actual discretization of the <code>X</code> dimension. Its name has been specified before, but we now set its parameters.</p>
<div class="fragment"><div class="line">    <span class="comment">// Initialization of the global domain in X with gwx ghost points on</span></div>
<div class="line">    <span class="comment">// each side</span></div>
<div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> [x_domain, ghosted_x_domain, x_pre_ghost, x_post_ghost]</div>
<div class="line">            = init_discretization&lt;DDimX&gt;(DDimX::init_ghosted(</div>
<div class="line">                    Coordinate&lt;X&gt;(x_start),</div>
<div class="line">                    Coordinate&lt;X&gt;(x_end),</div>
<div class="line">                    DiscreteVector&lt;DDimX&gt;(nb_x_points),</div>
<div class="line">                    gwx));</div>
</div><!-- fragment --><p> Since we use the <code>init_ghosted</code> function, we receive four 1D domains as a result. Their type is not specified because we use C++ <a href="https://en.cppreference.com/w/cpp/language/structured_binding">structured bindings</a>, but they are all of the same type: <code><a class="el" href="classDiscreteDomain.html">DiscreteDomain</a>&lt;DDimX&gt;</code> that represents a set of contiguous points in the discretization of <code>X</code>. This function expects as parameter the coordinate of the first and last discretized points, the number of discretized points in the domain and the number of additional points on each side of the domain. The fours <code><a class="el" href="classDiscreteDomain.html">DiscreteDomain</a></code>s returned are:</p><ul>
<li><code>x_domain</code>: the main domain from the start (included) to end (included) but excluding "ghost" points.</li>
<li><code>ghosted_x_domain</code>: the domain including all "ghost" points.</li>
<li><code>x_pre_ghost</code>: the "ghost" points that come before the main domain.</li>
<li><code>x_post_ghost</code>: the "ghost" points that come after the main domain.</li>
</ul>
<p>The parameters of raw C++ types like <code>double</code> or <code>size_t</code> can not be used as-is since DDC enforces strong typing. Instead, for a coordinate in the <code>X</code> dimension, we use <code>Coordinate&lt;X&gt;</code> and &ndash;as already mentioned&ndash; for a number of elements in the discretization of <code>X</code>, we use <code>DiscreteVector&lt;DDimX&gt;</code>.</p>
<p>Once this is done, we define two additional domains.</p>
<div class="fragment"><div class="line">    <span class="comment">// our zone at the start of the domain that will be mirrored to the</span></div>
<div class="line">    <span class="comment">// ghost</span></div>
<div class="line">    <a class="code" href="classDiscreteDomain.html">DiscreteDomain</a> <span class="keyword">const</span></div>
<div class="line">            x_domain_begin(x_domain.front(), x_post_ghost.extents());</div>
<div class="line">    <span class="comment">// our zone at the end of the domain that will be mirrored to the</span></div>
<div class="line">    <span class="comment">// ghost</span></div>
<div class="line">    <a class="code" href="classDiscreteDomain.html">DiscreteDomain</a> <span class="keyword">const</span> x_domain_end(</div>
<div class="line">            x_domain.back() - x_pre_ghost.extents() + 1,</div>
<div class="line">            x_pre_ghost.extents());</div>
</div><!-- fragment --><p> <code>x_domain_begin</code> is the sub-domain at the beginning of <code>x_domain</code> of the same shape as <code>x_post_ghost</code> that will be mirrored to it. Reciprocally for <code>x_domain_end</code> with <code>x_pre_ghost</code>.</p>
<p>The type of both sub-domains is <code><a class="el" href="classDiscreteDomain.html">DiscreteDomain</a>&lt;DDimX&gt;</code> even if only <code><a class="el" href="classDiscreteDomain.html">DiscreteDomain</a></code> is specified, this relies on C++ <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">class template argument deduction (CTAD)</a>. The first parameter given to the constructor is the first element of the domain, a <code>DiscreteCoordinate&lt;DDimX&gt;</code>, the second parameter is a number of elements to include, a <code>DiscreteVector&lt;DDimX&gt;</code>.</p>
<p><b>To summarize,</b> in this section, we have introduced the following types:</p><ul>
<li><code>Coordinate&lt;X&gt;</code> that represents a point in the continuous dimension <code>X</code>,</li>
<li><code>DiscreteCoordinate&lt;DDimX&gt;</code> that represents one of the elements of <code>DDimX</code>, the discretization of <code>X</code>,</li>
<li><code>DiscreteVector&lt;DDimX&gt;</code> that represents a number of elements of <code>DDimX</code>,</li>
<li><code><a class="el" href="classDiscreteDomain.html">DiscreteDomain</a>&lt;DDimX&gt;</code> that represents an interval in <code>DDimX</code>, a set of contiguous elements of the discretization.</li>
</ul>
<h3><a class="anchor" id="autotoc_md6"></a>
Dimension Y</h3>
<p>The domains in the <code>Y</code> dimension are handled in a way very similar to the <code>X</code> dimension.</p>
<div class="fragment"><div class="line">    <span class="comment">// Number of ghost points to use on each side in Y</span></div>
<div class="line">    DiscreteVector&lt;DDimY&gt; <span class="keyword">static</span> constexpr gwy {1};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Initialization of the global domain in Y with gwy ghost points on</span></div>
<div class="line">    <span class="comment">// each side</span></div>
<div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> [y_domain, ghosted_y_domain, y_pre_ghost, y_post_ghost]</div>
<div class="line">            = init_discretization(DDimY::init_ghosted(</div>
<div class="line">                    Coordinate&lt;Y&gt;(y_start),</div>
<div class="line">                    Coordinate&lt;Y&gt;(y_end),</div>
<div class="line">                    DiscreteVector&lt;DDimY&gt;(nb_y_points),</div>
<div class="line">                    gwy));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// our zone at the start of the domain that will be mirrored to the</span></div>
<div class="line">    <span class="comment">// ghost</span></div>
<div class="line">    <a class="code" href="classDiscreteDomain.html">DiscreteDomain</a> <span class="keyword">const</span></div>
<div class="line">            y_domain_begin(y_domain.front(), y_post_ghost.extents());</div>
<div class="line">    <span class="comment">// our zone at the end of the domain that will be mirrored to the</span></div>
<div class="line">    <span class="comment">// ghost</span></div>
<div class="line">    <a class="code" href="classDiscreteDomain.html">DiscreteDomain</a> <span class="keyword">const</span> y_domain_end(</div>
<div class="line">            y_domain.back() - y_pre_ghost.extents() + 1,</div>
<div class="line">            y_pre_ghost.extents());</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md7"></a>
Time dimension</h3>
<p>Then we handle the domains for the simulated time dimension.</p>
<div class="fragment"><div class="line">    <span class="comment">// max(1/dx^2)</span></div>
<div class="line">    <span class="keywordtype">double</span> <span class="keyword">const</span> invdx2_max = transform_reduce(</div>
<div class="line">            x_domain,</div>
<div class="line">            0.,</div>
<div class="line">            <a class="code" href="structreducer_1_1max.html">reducer::max&lt;double&gt;</a>(),</div>
<div class="line">            [](DiscreteCoordinate&lt;DDimX&gt; ix) {</div>
<div class="line">                <span class="keywordflow">return</span> 1.</div>
<div class="line">                       / (distance_at_left(ix) * distance_at_right(ix));</div>
<div class="line">            });</div>
<div class="line">    <span class="comment">// max(1/dy^2)</span></div>
<div class="line">    <span class="keywordtype">double</span> <span class="keyword">const</span> invdy2_max = transform_reduce(</div>
<div class="line">            y_domain,</div>
<div class="line">            0.,</div>
<div class="line">            <a class="code" href="structreducer_1_1max.html">reducer::max&lt;double&gt;</a>(),</div>
<div class="line">            [](DiscreteCoordinate&lt;DDimY&gt; iy) {</div>
<div class="line">                <span class="keywordflow">return</span> 1.</div>
<div class="line">                       / (distance_at_left(iy) * distance_at_right(iy));</div>
<div class="line">            });</div>
<div class="line">    Coordinate&lt;T&gt; <span class="keyword">const</span> max_dt {</div>
<div class="line">            .5 / (kx * invdx2_max + ky * invdy2_max)};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// number of time intervals required to reach the end time</span></div>
<div class="line">    DiscreteVector&lt;DDimT&gt; <span class="keyword">const</span> nb_time_steps {</div>
<div class="line">            std::ceil((end_time - start_time) / max_dt) + .2};</div>
<div class="line">    <span class="comment">// Initialization of the global domain in time:</span></div>
<div class="line">    <span class="comment">// - the number of discrete time-points is equal to the number of</span></div>
<div class="line">    <span class="comment">//   steps + 1</span></div>
<div class="line">    <a class="code" href="classDiscreteDomain.html">DiscreteDomain&lt;DDimT&gt;</a> <span class="keyword">const</span> time_domain</div>
<div class="line">            = init_discretization(DDimT::</div>
<div class="line">                                          init(Coordinate&lt;T&gt;(start_time),</div>
<div class="line">                                               Coordinate&lt;T&gt;(end_time),</div>
<div class="line">                                               nb_time_steps + 1));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Data allocation</h1>
<p>We allocate two 2D Chunks along the X and Y dimensions which will be used to map temperature to the domains' points at t and t+dt.</p>
<div class="fragment"><div class="line">    <span class="comment">// Maps temperature into the full domain (including ghosts) twice:</span></div>
<div class="line">    <span class="comment">// - once for the last fully computed time-step</span></div>
<div class="line">    <a class="code" href="namespace_3globalScope_4.html#classChunk">Chunk&lt;double, DiscreteDomain&lt;DDimX, DDimY&gt;</a>&gt; ghosted_last_temp(</div>
<div class="line">            <a class="code" href="classDiscreteDomain.html">DiscreteDomain</a>&lt;</div>
<div class="line">                    DDimX,</div>
<div class="line">                    DDimY&gt;(ghosted_x_domain, ghosted_y_domain));</div>
<div class="line">    <span class="comment">// - once for time-step being computed</span></div>
<div class="line">    <a class="code" href="namespace_3globalScope_4.html#classChunk">Chunk&lt;double, DiscreteDomain&lt;DDimX, DDimY&gt;</a>&gt; ghosted_next_temp(</div>
<div class="line">            <a class="code" href="classDiscreteDomain.html">DiscreteDomain</a>&lt;</div>
<div class="line">                    DDimX,</div>
<div class="line">                    DDimY&gt;(ghosted_x_domain, ghosted_y_domain));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9"></a>
Initial conditions</h1>
<div class="fragment"><div class="line">    <span class="comment">// Initialize the temperature on the main domain</span></div>
<div class="line">    for_each(</div>
<div class="line">            <a class="code" href="classDiscreteDomain.html">DiscreteDomain&lt;DDimX, DDimY&gt;</a>(x_domain, y_domain),</div>
<div class="line">            [&amp;](DiscreteCoordinate&lt;DDimX, DDimY&gt; <span class="keyword">const</span> ixy) {</div>
<div class="line">                <span class="keywordtype">double</span> <span class="keyword">const</span> x = to_real(select&lt;DDimX&gt;(ixy));</div>
<div class="line">                <span class="keywordtype">double</span> <span class="keyword">const</span> y = to_real(select&lt;DDimY&gt;(ixy));</div>
<div class="line">                ghosted_last_temp(ixy)</div>
<div class="line">                        = 9.999 * ((x * x + y * y) &lt; 0.25);</div>
<div class="line">            });</div>
</div><!-- fragment --> <div class="fragment"><div class="line">    <span class="comment">// display the initial data</span></div>
<div class="line">    display(to_real(time_domain.<a class="code" href="classDiscreteDomain.html#aa86d4b50cf388190d96e63420f9d6909">front</a>()),</div>
<div class="line">            ghosted_last_temp[x_domain][y_domain]);</div>
<div class="line">    <span class="comment">// time of the iteration where the last output happened</span></div>
<div class="line">    DiscreteCoordinate&lt;DDimT&gt; last_output = time_domain.<a class="code" href="classDiscreteDomain.html#aa86d4b50cf388190d96e63420f9d6909">front</a>();</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md10"></a>
Time loop</h1>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> iter :</div>
<div class="line">         <a class="code" href="classDiscreteDomain.html">DiscreteDomain</a> {time_domain.<a class="code" href="classDiscreteDomain.html#aa86d4b50cf388190d96e63420f9d6909">front</a>() + 1, nb_time_steps - 1}) {</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Periodic conditions</h2>
<div class="fragment"><div class="line">        <span class="comment">// Periodic boundary conditions</span></div>
<div class="line">        deepcopy(</div>
<div class="line">                ghosted_last_temp[x_pre_ghost][y_domain],</div>
<div class="line">                ghosted_last_temp[y_domain][x_domain_end]);</div>
<div class="line">        deepcopy(</div>
<div class="line">                ghosted_last_temp[y_domain][x_post_ghost],</div>
<div class="line">                ghosted_last_temp[y_domain][x_domain_begin]);</div>
<div class="line">        deepcopy(</div>
<div class="line">                ghosted_last_temp[x_domain][y_pre_ghost],</div>
<div class="line">                ghosted_last_temp[x_domain][y_domain_end]);</div>
<div class="line">        deepcopy(</div>
<div class="line">                ghosted_last_temp[x_domain][y_post_ghost],</div>
<div class="line">                ghosted_last_temp[x_domain][y_domain_begin]);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
Numerical scheme</h2>
<div class="fragment"><div class="line">        <span class="comment">// a span excluding ghosts of the temperature at the time-step we</span></div>
<div class="line">        <span class="comment">// will build</span></div>
<div class="line">        <a class="code" href="namespace_3globalScope_4.html#classChunkSpan">ChunkSpan</a> <span class="keyword">const</span> next_temp {</div>
<div class="line">                ghosted_next_temp[x_domain][y_domain]};</div>
<div class="line">        <span class="comment">// a read-only view of the temperature at the previous time-step</span></div>
<div class="line">        <a class="code" href="namespace_3globalScope_4.html#classChunkSpan">ChunkSpan</a> <span class="keyword">const</span> last_temp {ghosted_last_temp.span_view()};</div>
</div><!-- fragment --> <div class="fragment"><div class="line">        <span class="comment">// Stencil computation on the main domain</span></div>
<div class="line">        for_each(</div>
<div class="line">                next_temp.domain(),</div>
<div class="line">                [&amp;](DiscreteCoordinate&lt;DDimX, DDimY&gt; <span class="keyword">const</span> ixy) {</div>
<div class="line">                    DiscreteCoordinate&lt;DDimX&gt; const ix</div>
<div class="line">                            = select&lt;DDimX&gt;(ixy);</div>
<div class="line">                    DiscreteCoordinate&lt;DDimY&gt; const iy</div>
<div class="line">                            = select&lt;DDimY&gt;(ixy);</div>
<div class="line">                    double const dx_l = distance_at_left(ix);</div>
<div class="line">                    double const dx_r = distance_at_right(ix);</div>
<div class="line">                    double const dx_m = 0.5 * (dx_l + dx_r);</div>
<div class="line">                    double const dy_l = distance_at_left(iy);</div>
<div class="line">                    double const dy_r = distance_at_right(iy);</div>
<div class="line">                    double const dy_m = 0.5 * (dy_l + dy_r);</div>
<div class="line">                    next_temp(ix, iy) = last_temp(ix, iy);</div>
<div class="line">                    next_temp(ix, iy)</div>
<div class="line">                            += kx * max_dt</div>
<div class="line">                               * (dx_l * last_temp(ix + 1, iy)</div>
<div class="line">                                  - 2.0 * dx_m * last_temp(ix, iy)</div>
<div class="line">                                  + dx_r * last_temp(ix - 1, iy))</div>
<div class="line">                               / (dx_l * dx_m * dx_r);</div>
<div class="line">                    next_temp(ix, iy)</div>
<div class="line">                            += ky * max_dt</div>
<div class="line">                               * (dy_l * last_temp(ix, iy + 1)</div>
<div class="line">                                  - 2.0 * dy_m * last_temp(ix, iy)</div>
<div class="line">                                  + dy_r * last_temp(ix, iy - 1))</div>
<div class="line">                               / (dy_l * dy_m * dy_r);</div>
<div class="line">                });</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
Output</h2>
<div class="fragment"><div class="line">        <span class="keywordflow">if</span> (iter - last_output &gt;= t_output_period) {</div>
<div class="line">            last_output = iter;</div>
<div class="line">            display(to_real(iter), next_temp);</div>
<div class="line">        }</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
Final swap</h2>
<div class="fragment"><div class="line">        <span class="comment">// Swap our two buffers</span></div>
<div class="line">        std::swap(ghosted_last_temp, ghosted_next_temp);</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md15"></a>
Final output</h1>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (last_output &lt; time_domain.<a class="code" href="classDiscreteDomain.html#a569cda957f2d1a99880d33e31b15acde">back</a>()) {</div>
<div class="line">        display(to_real(time_domain.<a class="code" href="classDiscreteDomain.html#a569cda957f2d1a99880d33e31b15acde">back</a>()),</div>
<div class="line">                ghosted_last_temp[x_domain][y_domain]);</div>
<div class="line">    }</div>
</div><!-- fragment --></div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aclassUniformDiscretization_html"><div class="ttname"><a href="classUniformDiscretization.html">UniformDiscretization</a></div><div class="ttdoc">UniformDiscretization models a uniform discretization of the provided continuous dimension.</div><div class="ttdef"><b>Definition:</b> uniform_discretization.hpp:16</div></div>
<div class="ttc" id="anamespace_3globalScope_4_html_classChunkSpan"><div class="ttname"><a href="namespace_3globalScope_4.html#classChunkSpan">ChunkSpan</a></div><div class="ttdef"><b>Definition:</b> chunk_span.hpp:22</div></div>
<div class="ttc" id="aclassDiscreteDomain_html"><div class="ttname"><a href="classDiscreteDomain.html">DiscreteDomain</a></div><div class="ttdef"><b>Definition:</b> discrete_domain.hpp:17</div></div>
<div class="ttc" id="anamespace_3globalScope_4_html_classChunk"><div class="ttname"><a href="namespace_3globalScope_4.html#classChunk">Chunk</a></div><div class="ttdef"><b>Definition:</b> chunk.hpp:11</div></div>
<div class="ttc" id="aclassDiscreteDomain_html_aa86d4b50cf388190d96e63420f9d6909"><div class="ttname"><a href="classDiscreteDomain.html#aa86d4b50cf388190d96e63420f9d6909">DiscreteDomain::front</a></div><div class="ttdeci">constexpr mcoord_type front() const noexcept</div><div class="ttdef"><b>Definition:</b> discrete_domain.hpp:122</div></div>
<div class="ttc" id="aclassDiscreteDomain_html_a569cda957f2d1a99880d33e31b15acde"><div class="ttname"><a href="classDiscreteDomain.html#a569cda957f2d1a99880d33e31b15acde">DiscreteDomain::back</a></div><div class="ttdeci">constexpr mcoord_type back() const noexcept</div><div class="ttdef"><b>Definition:</b> discrete_domain.hpp:127</div></div>
<div class="ttc" id="astructreducer_1_1max_html"><div class="ttname"><a href="structreducer_1_1max.html">reducer::max</a></div><div class="ttdef"><b>Definition:</b> reducer.hpp:95</div></div>
</body>
</html>
