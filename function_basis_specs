API ddc:FunctionsBasis
- Aims to represent discrete functions in basis others than Dirac one (= values of the function evaluated on each point of the mesh).
- Coefficients of the function in the basis are stored in a mdspan. For each function basis (ie. Splines or Lagrange) builders and evaluators are provided. No need to associate a DiscreteDomain (mesh) to those basis in a first place (Note : a possible improvement would be to include Fourier basis in this scope - the builder would be FFT and the evaluator would be iFFT - but it would requires to store coefficients in a ChunkSpan linked to the mesh of the spectral domain instead of a mdspan).
- Several storage methods (Full, Band, CSR), numerical solvers (direct for Lagrange, based on gesv+gbsv or Krylov for splines) and interfaces to libraries to perform the computation (LAPACK, Slate, PETSc) are provided. Data can be stored on CPU or GPU. MPI compatibility should be next step.

-----

Several interface classes and their childs:
- IFunctionDimensionTag -> Aims to identify the dimensions
--- Spline<X>
--- SplineUniform<X>
--- SplineNonUniform<X>
--- CartesianSpline<X...>
--- PolarSpline<R,P>
--- LagrangePolynome<X>
--- ...
- Builder -> Aims to fill the mdspan which contains the coefficients of the function in the basis. Tags names are enough to identify which Builder is used (1D lagrange builder, 2D spline builder etc...). Takes a solver in the constructor.
- Evaluator -> Aims to fill a ChunkSpan which contains the values of the function on each point of the mesh from the coefficient in the basis.
- ISolver (passed to builder)
--- LagrangeDirectComputation (computes the coefficients of Lagrange polynomials directly with Kokkos)
--- LapackLUSplines (current method in Gysela, not available on GPU)
--- SlateLUSplines (same but with Slate, involves GPU)
--- PetscSparseSplines (consider splines linear problem as sparse and uses Krylov methods)
- Vector -> Generic class for a vector (for linear algebra purpose, unrelated to ddc::DiscreteVector). Contains data pointer and links internally to libraries representations (Petsc::Vec etc.)
- IMatrix -> Matrixes. Determines the storage method. Contains data pointer and links internally to libraries representations (Petsc::Mat, Slate::Matrix etc.).
--- DenseMatrix
--- SparseMatrix
--- BandMatrix
--- BandSparseMatrix ?
--- PDSTridiagMatrix
--- CenterBlocksMatrix
--- CornerBlocksMatrix
--- SplinesBuilderMatrix (BandMatrix in the top-left corner, DenseMatrix in the others)
--- SplinesSparseBuilderMatrix (BandSparseMatrix in the top-left corner, SparseMatrix in the others) ?

+ Several application usage classes :
- Interpolator (calls Builder then Evaluator of differents DiscreteDomains).
- FEMSolver ?
- ...

-----

Examples of (prototypes of) classes. Please don't give importance to & and * symbols, I will think more on how to manage pointers in order to never copy data:

template <typename X, std::size_t D> // X is associated spatial dimension tag, D is degree
class Something : IFunctionDimensionTag {
	using spatial_dimension = X;
	using continuous_dimension_type; // ie. Spline<X>
	using discrete_element_type;
    using discrete_domain_type;
    using discrete_vector_type;
    get_knot() related functions ? // Important point, to be discussed -> in the end, should we link a mesh to function basis coefs to identify for example the spatial position of a spline ?
}

class Builder {
	template <typename... FunctionDimensionTag>
	Builder(ISolver<FunctionDimensionTag...> solver) {
		// Instantiate a builder based on a solver.
	}
	mdspan operator()(ddc::ChunkSpan data) {
		// calls the builder and returns the coefficients in the functions basis
	}
}

class Evaluator {
	ddc::ChunkSpan operator()(mdspan* coefs, ddc::DiscreteDomain mesh) {
		// evaluates function on the mesh
	}
}

class ISolver {
	// Main algorithms + intermediate functions (note : content of factorize() or factorize_method() in current code goes there with a specialization for each supported Matrix class)
}

class Vector {
	mdspan* data;
	size_t n;
	#if PETSC_AVAIL
	PETSc::Vec petsc_vec;
	#endif
	Vector(double* vec, size_t n) {
		// Build petsc_vec
	}
}

class IMatrix {
	mdspan* data;
	size_t n;
	size_t m;
	#if SLATE_AVAIL
	SLATE::Mat slate_mat;
	#endif
	#if PETSC_AVAIL
	PETSc::Vec slate_mat;
	#endif

	IMatrix(double* vec, size_t n) {
		// Build slate_mat. In the (seemly quite complex) case of Slate::BandMatrix, handle tiles assembly.
		// Build petsc_mat
	}
}

